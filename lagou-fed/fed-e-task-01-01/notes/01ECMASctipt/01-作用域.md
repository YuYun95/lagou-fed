## let与块级作用域
作用域-- 某个成员能够起作用的范围

ES2015前，ES只有两种作用域，分别是全局作用域和函数作用域；在ES2015中新增了一个块级作用域

块：代码中用一对花括号包 '{}' 裹起来的代码，如：
```javascript
if (true){
  console.log('if')
}

for (var i = 0; i < 10; i++){
  console.log('for')
}
```
以前块没有独立的作用域，所以在块中定义的变量，块的外面也可以访问，如：
```javascript
if (true){
  var foo = 'foo'
}
console.log(foo)
```
这对于代码是非常不利的、不安全的，有了块级作用域，可以通过新的关键字let去声明变量，用法跟传统一样，只是let声明的变量只能在声明的代码块中使用，外部无法访问的，如：
```javascript
if (true){
  let foo = 'foo'
}
console.log(foo) // foo is not defined
```
传统for循环如果多个for循环嵌套，那么就要声明不同名称的计数器，不然出现问题，如下代码本应输出九次，但是却输出三次，因为内层声明的i会覆盖外层声明的i
```javascript
for (var i = 0; i < 3; i++){
  for (var i = 0; i < 3; i++){
    console.log(i)
  }
  console.log('内存循环结束 i =' + i)
}
```
而使用let声明的变量不会出现上面的问题，因为内层声明的i变量是内层块作用域的成员
```javascript
for (let i = 0; i < 3; i++){
  for (let i = 0; i < 3; i++){
    console.log(i)
  }
  console.log('内存循环结束 i =' + i)
}
```

```javascript

var elements = [{}, {}, {}]
for(var i = 0; i < elements.length; i++){
  elements[i].onclick = function() {
    console.log(i) // 输出 3，因为i始终指向全局的i，循环执行后i已经累加到了3
  }
}
elements[0].onclick()
```
解决上面的问题可以通过闭包，借助函数作用域拜托全局作用域的影响
```javascript
var elements = [{}, {}, {}]
for(var i = 0; i < elements.length; i++){
  (function(i) {
    elements[i].onclick = function() {
        console.log(i)
      }
  })(i)
}
elements[0].onclick()
```
有了块级作用域就不需要如此麻烦；其实内部也是闭包的机制，当onclick执行是寻找早已执行完毕，i 早已销毁，因为闭包的机制我们才能拿到i对应的值
```javascript
var elements = [{}, {}, {}]
for(let i = 0; i < elements.length; i++){
  elements[i].onclick = function() {
    console.log(i)
  }
}
elements[0].onclick()
```
for循环内部有两层作用域，当声明两个一样的 i 时，他们会在不同的作用域中(两层嵌套的作用域)、互不影响，循环体的 i 是内层作用域，外层 i 是for循环本身的作用域
```javascript
for (let i = 0; i< 2; i++){
  let i = 'foo'
  console.log(i)
}

// 可以拆解为
let i = 0

if (i < 2) {
  let i = 'foo'
  console.log(i)
}

i++

let i = 0

if (i < 2) {
  let i = 'foo'
  console.log(i)
}

i++
```
let声明的变量不会出现变量提升的情况，需要先声明变量再去使用变量，否则报错；传统的var声明的变量会导致变量提升
```javascript
console.log(foo) // undefined，说明变量已经声明，只是还没赋值，这种现象叫做变量声明的提升
var foo = 'foo'
console.log(bar) // 报错
let bar = 'bar'
```


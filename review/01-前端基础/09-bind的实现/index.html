<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /**
       * bind()方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，
       * 之后的一序列参数将会在传递的实参前传入作为它的参数。
       * 两个特点：返回一个函数、可以传入参数
       *
       * 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时
       * 调用时的参数被提供给模拟函数
       * 也就是说，当bind返回的函数作为构造函数的时候，bind是指定的值会失效，单传入的参数依然生效
       */
      var foo = {
        value: 1
      }
      function bar() {
        console.log(this.value)
      }

      var bindFoo = bar.bind(foo)
      bindFoo()

      // 返回函数模拟实现
      Function.prototype.bind2 = function (context) {
        var self = this
        return function () {
          return self.apply(context) // 考虑到绑定函数可能是有返回值
        }
      }
      console.log('-------------------------------------------------------------------------')
      /**
       * 传参的模拟实现
       * 执行bind是否可以传入参数、执行bind返回的函数是否可以传入参数
       */
      var foo = {
        value: 1
      }
      function bar(name, age) {
        console.log(this.value)
        console.log(name)
        console.log(age)
      }

      var bindFoo = bar.bind(foo, 'zyh') // 1 zyh
      bindFoo(21) // 21

      // 传参的模拟实现
      Function.prototype.bind2 = function (context) {
        var self = this
        // 获取bind2函数从第二个参数到最后一个参数
        var args = Array.prototype.slice.call(arguments, 1)

        return function () {
          console.log('con', context)
          // 这个时候的arguments是指bind返回的函数传入的参数
          var bindArgs = Array.prototype.slice.call(arguments)
          return self.apply(context, args.concat(bindArgs))
        }
      }

      var bindFoo = bar.bind2(foo, 'yan') // 1 yan
      bindFoo('22') // 22

      console.log('-------------------------------------------------------------------------')
      // 构造函数效果的模拟实现
      var value = 2
      var foo = {
        value: 1
      }

      function bar(name, age) {
        this.habit = 'shopping'
        console.log(this.value)
        console.log(name)
        console.log(age)
      }

      bar.prototype.friend = 'kenvi'

      var bindFoo = bar.bind(foo, 'daisy')

      var obj = new bindFoo('18') // undefined、daisy、18

      console.log(obj.habit) // shopping
      console.log(obj.friend) // kenvi

      /**
       * 构造函数效果的模拟实现
       */

       Function.prototype.bind3 = function(context) {
         var self = this
         var args = Array.prototype.slice.call(arguments, 1)

         var fBound = function() {
           var bindArgs = Array.prototype.slice.call(arguments)
           // 当作为构造函数时，this 指向实例，此时结果为true，
         }
       }
    </script>
  </body>
</html>
